<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Spring]]></title><description><![CDATA[Level up your Java code and explore what Spring can do for you.]]></description><link>https://spring.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 22 Oct 2025 05:07:04 GMT</lastBuildDate><item><title><![CDATA[Spring for Apache Pulsar 1.2.11 and 2.0.0-RC1 are now available]]></title><link>https://spring.io/blog/2025/10/22/spring-for-apache-pulsar-1-2-11-and-2-0-0-RC1-are-now-available</link><guid isPermaLink="true">https://spring.io/blog/2025/10/22/spring-for-apache-pulsar-1-2-11-and-2-0-0-RC1-are-now-available</guid><dc:creator><![CDATA[onobc]]></dc:creator><pubDate>Wed, 22 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the team and everyone who has contributed, I¡¯m happy to announce that Spring for Apache Pulsar &lt;code&gt;1.2.11&lt;/code&gt; and &lt;code&gt;2.0.0-RC1&lt;/code&gt; have been released and are now available from Maven Central.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;1.2.11&lt;/code&gt; release will be included in the upcoming Spring Boot &lt;a href=&quot;https://github.com/spring-projects/spring-boot/milestones/3.4.11&quot;&gt;3.4.11&lt;/a&gt; and  &lt;a href=&quot;https://github.com/spring-projects/spring-boot/milestones/3.5.7&quot;&gt;3.5.7&lt;/a&gt; releases.
The &lt;code&gt;2.0.0-RC1&lt;/code&gt; release will be included in the upcoming Spring Boot &lt;a href=&quot;https://github.com/spring-projects/spring-boot/milestones/4.0.0-RC1&quot;&gt;4.0.0-RC1&lt;/a&gt; release.&lt;/p&gt;
&lt;p&gt;Please see the release notes (&lt;a href=&quot;https://github.com/spring-projects/spring-pulsar/releases/tag/v1.2.11&quot;&gt;1.2.11&lt;/a&gt; and &lt;a href=&quot;https://github.com/spring-projects/spring-pulsar/releases/tag/v2.0.0-RC1&quot;&gt;2.0.0-RC1&lt;/a&gt;) for more details.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Multi-Factor Authentication in Spring Security 7]]></title><link>https://spring.io/blog/2025/10/21/multi-factor-authentication-in-spring-security-7</link><guid isPermaLink="true">https://spring.io/blog/2025/10/21/multi-factor-authentication-in-spring-security-7</guid><dc:creator><![CDATA[jzheaux]]></dc:creator><pubDate>Tue, 21 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;In 2013, it was proposed to &lt;a href=&quot;https://github.com/spring-projects/spring-security/issues/2603&quot;&gt;add multi-factor authentication&lt;/a&gt; into Spring Security. That was the year that ¡°selfie¡± was added to the English dictionary and ¡°What Does the Fox Say?¡± was a viral YouTube hit.&lt;/p&gt;
&lt;p&gt;Needless to say, one of the biggest features in Spring Security 7 is a long time coming, and is our next stop along our &lt;a href=&quot;https://spring.io/blog/2025/09/02/road_to_ga_introduction&quot;&gt;Road to GA&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;what-is-multi-factor-authentication-mfa&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#what-is-multi-factor-authentication-mfa&quot; aria-label=&quot;what is multi factor authentication mfa permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;What is Multi-Factor Authentication (MFA)?&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-security/reference/7.0-SNAPSHOT/servlet/authentication/mfa.html&quot;&gt;Multi-Factor Authentication&lt;/a&gt; is an authentication strategy by which your identity is determined on a website by more than one means of verification, or &lt;em&gt;factor&lt;/em&gt;. Common factors fall into one of a few categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Something you &lt;strong&gt;know&lt;/strong&gt;; like a password or an answer to a security question&lt;/li&gt;
&lt;li&gt;Something you &lt;strong&gt;have&lt;/strong&gt;; like an app on your cell phone&lt;/li&gt;
&lt;li&gt;Something you &lt;strong&gt;are&lt;/strong&gt;; like a thumbprint or other biometric&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For example, when you give your username and password, and then are asked to enter a code sent to your email, that¡¯s multi-factor authentication.
The username and password are things you &lt;strong&gt;know&lt;/strong&gt;, and your email is something you &lt;strong&gt;have&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Multi-factor authentication increases the confidence an application can have that the user is who they claim to be.&lt;/p&gt;
&lt;h2 id=&quot;mfa-features-that-spring-security-supports&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#mfa-features-that-spring-security-supports&quot; aria-label=&quot;mfa features that spring security supports permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;MFA Features that Spring Security Supports&lt;/h2&gt;
&lt;p&gt;As of this writing, Spring Security supports several important MFA use cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Globally requiring multiple factors&lt;/strong&gt; of a user in a specified order&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conditionally requiring multiple factors&lt;/strong&gt;, configurable by web endpoint or method signature&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Time-based authentication&lt;/strong&gt; so that you can require users re-authenticate for certain endpoints after a given time&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;User-based authentication&lt;/strong&gt; so that you can take care of opt-in scenarios where not all of your users are using MFA yet&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Integration with Custom &lt;code&gt;AuthenticationProvider&lt;/code&gt;s&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In this blog post, we¡¯ll take a look at each one of these.
First, though, let¡¯s understand how MFA is modeled in Spring Security&lt;/p&gt;
&lt;h2 id=&quot;how-spring-security-models-mfa-through-progressive-authorization&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#how-spring-security-models-mfa-through-progressive-authorization&quot; aria-label=&quot;how spring security models mfa through progressive authorization permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;How Spring Security Models MFA Through Progressive Authorization&lt;/h2&gt;
&lt;p&gt;The key insight to bringing MFA into Spring Security is the humble &lt;code&gt;GrantedAuthority&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Initially, it may seem odd to describe an authentication strategy in terms of authorization until you consider that authorization rules can and often do take into consideration the way authentication was obtained.&lt;/p&gt;
&lt;p&gt;For example, a website may only authorize requests to a portion of their website if you have authenticated in the last 5 minutes, if you have verified your email address, or if you were authorized by a particular OAuth 2.0 issuer.&lt;/p&gt;
&lt;p&gt;To facilitate this, Spring Security 7 issues a &lt;em&gt;factor&lt;/em&gt; &lt;code&gt;GrantedAuthority&lt;/code&gt; for each successful authentication.&lt;/p&gt;
&lt;p&gt;With this simple change, MFA in Spring Security becomes the progressive granting of authorities; one granted with each successful authentication. You get to write authorization rules that state which authentication factors matter to you where.&lt;/p&gt;
&lt;p&gt;Then, when a factor authority is missing, Spring Security redirects the end user to the endpoint where that authority can be obtained. For example, a rule that requires &lt;code&gt;FACTOR_PASSWORD&lt;/code&gt; will cause Spring Security to redirect to the &lt;code&gt;/login&lt;/code&gt; page to obtain the user¡¯s username and password.&lt;/p&gt;
&lt;p&gt;Imagine an authorization rule like this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@PreAuthorize(&quot;hasAllAuthorities(&apos;FACTOR_PASSWORD&apos;, &apos;FACTOR_X509&apos;, &apos;ROLE_ADMIN&apos;)&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This rule states that the end user must be an admin, but also must have provided their username, password (which issues a &lt;code&gt;FACTOR_PASSWORD&lt;/code&gt; authority), and an X.509 certificate (which issues a &lt;code&gt;FACTOR_X509&lt;/code&gt; authority) to identify themselves.&lt;/p&gt;
&lt;p&gt;Using authorities provides a simple and effective short-hand for requiring multiple types of authentication for any given endpoint or method invocation.&lt;/p&gt;
&lt;h2 id=&quot;enabling-mfa-globally&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#enabling-mfa-globally&quot; aria-label=&quot;enabling mfa globally permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Enabling MFA Globally&lt;/h2&gt;
&lt;p&gt;Now, while the above &lt;code&gt;@PreAuthorize&lt;/code&gt; rule will work, specifying each factor for every authorization rule can get tedious.
And less repetition with authorization rules means fewer coding mistakes in sensitive code.&lt;/p&gt;
&lt;p&gt;To that end, you can enable MFA in Spring Security by listing the required authorities in the &lt;code&gt;@EnableGlobalMultiFactorAuthentication&lt;/code&gt; annotation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@EnableGlobalMultiFactorAuthentication(FactorGrantedAuthority.PASSWORD_AUTHORITY, FactorGrantedAuthority.X509_AUTHORITY)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will add an implicit check to all authorization rules to require that the user provide their username and password (something they know) and an X.509 certificate (something they have) before showing any page that requires authentication.&lt;/p&gt;
&lt;p&gt;The only thing left is to declare the appropriate configurations for each authentication mechanism:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@EnableGlobalMultiFactorAuthentication(authorities = {
	FactorGrantedAuthority.PASSWORD_AUTHORITY, FactorGrantedAuthority.X509_AUTHORITY
})
@EnableWebSecurity
@EnableMethodSecurity
class SecurityConfig {

    @Bean 
    Customizer&amp;#x3C;HttpSecurity&gt; formLogin() {
        return (http) -&gt; http.formLogin(Customizer.withDefaults());
    }
    
    @Bean 
    Customizer&amp;#x3C;HttpSecurity&gt; x509Login() {
        return (http) -&gt; http.x509(Customizer.withDefaults());
    }
    
    @Bean 
    UserDetailsService users() {
        return new InMemoryUserDetailsManager(myTestUser);
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This changes the earlier &lt;code&gt;@PreAuthorize&lt;/code&gt; rule back to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@PreAuthorize(&quot;hasAuthority(&apos;ROLE_ADMIN&apos;)&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this way, if the end user has an X.509 certificate installed in their browser, they will also be redirected to &lt;code&gt;/login&lt;/code&gt; to provide the username/password factor.&lt;/p&gt;
&lt;p&gt;When MFA is not activated, activating the two mechanisms means the end user can authenticate using X.509 OR a username and password.&lt;/p&gt;
&lt;p&gt;[TIP]
Did you notice Spring Security¡¯s new support for &lt;a href=&quot;https://docs.spring.io/spring-security/reference/7.0-SNAPSHOT/servlet/configuration/java.html#httpsecurity-customizer-bean&quot;&gt;customizing &lt;code&gt;HttpSecurity&lt;/code&gt;&lt;/a&gt;?&lt;/p&gt;
&lt;h2 id=&quot;fine-grained-mfa-control-with-authorizationmanagerfactory&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#fine-grained-mfa-control-with-authorizationmanagerfactory&quot; aria-label=&quot;fine grained mfa control with authorizationmanagerfactory permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Fine-Grained MFA Control with &lt;code&gt;AuthorizationManagerFactory&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;There are a number of cases where you may not want to require multiple factors for every endpoint and method invocation.
In this case, you can use Spring Security¡¯s &lt;code&gt;AuthorizationManagerFactory&lt;/code&gt; to build-in the appropriate multi-factor rules programmatically.&lt;/p&gt;
&lt;p&gt;To do this, begin by creating an &lt;code&gt;AuthorizationManagerFactory&lt;/code&gt; instance, declaring your multiple factors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;AuthorizationManagerFactory&amp;#x3C;Object&gt; mfa = AuthorizationManagerFactories.multiFactor()
        .requireFactors(FactorGrantedAuthority.PASSWORD_AUTHORITY, FactorGrantedAuthority.X509_AUTHORITY)
        .build();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the same component that &lt;code&gt;@EnableGlobalMultiFactorAuthentication&lt;/code&gt; creates and publishes as a bean.&lt;/p&gt;
&lt;p&gt;In our case, we¡¯ll use it when describing our authorization rules:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Bean
Customizer&amp;#x3C;HttpSecurity&gt; authz() {
    AuthorizationManagerFactory&amp;#x3C;Object&gt; mfa = AuthorizationManagerFactories.multiFactor()
        .requireFactors(
            FactorGrantedAuthority.PASSWORD_AUTHORITY,
            FactorGrantedAuthority.X509_AUTHORITY).build();
    return (http) -&gt; http.authorizeHttpRequests((authorize) -&gt; authorize
        .requestMatchers(&quot;/admin/**¡±).access(mfa.hasRole(¡°ADMIN¡±))
        .anyRequest().authenticated());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The authorization rules in this application for &lt;code&gt;/admin/**&lt;/code&gt; will require a username and password, an X.509 certificate, and that the user have ROLE_ADMIN.
The rest of the application will only require one factor.&lt;/p&gt;
&lt;h2 id=&quot;time-based-authorization-rules&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#time-based-authorization-rules&quot; aria-label=&quot;time based authorization rules permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Time-Based Authorization Rules&lt;/h2&gt;
&lt;p&gt;Each time an authentication is completed, Spring Security issues the commensurate &lt;code&gt;FactorGrantedAuthority&lt;/code&gt; with a name and a timestamp.
This means that I can also write time-based authorization rules, like the ones you see on websites where, to get to a particular part of the site, they want you to log in again, if you haven¡¯t in the last five minutes.&lt;/p&gt;
&lt;p&gt;We can use &lt;code&gt;AuthorizationManagerFactory&lt;/code&gt; for this again, this time specifying the time needed for a given factor:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Bean
Customizer&amp;#x3C;HttpSecurity&gt; authz() {
    AuthorizationManagerFactory&amp;#x3C;Object&gt; recentLogin = AuthorizationManagerFactories.multiFactor()
        .requireFactor((f) -&gt; f.passwordAuthority().validDuration(Duration.ofMinutes(5)))
        .requireFactor((f) -&gt; f.x509Authority())
        .build();
    return (http) -&gt; http.authorizeHttpRequests((authorize) -&gt; authorize
        .requestMatchers(&quot;/profile/**&quot;).access(recentLogin.authenticated())
        .anyRequest().authenticated());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this way, the user can log in, navigate the site as normal, and be asked to re-authenticate when they go to the &lt;code&gt;/profile/me&lt;/code&gt; page.&lt;/p&gt;
&lt;h2 id=&quot;user-based-authorization-rules&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#user-based-authorization-rules&quot; aria-label=&quot;user based authorization rules permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;User-Based Authorization Rules&lt;/h2&gt;
&lt;p&gt;Business rules for multi-factor may also take into account only certain users, like those who have opted in to using MFA for their account.&lt;/p&gt;
&lt;p&gt;Consider an application that is using &lt;a href=&quot;https://docs.spring.io/spring-security/reference/7.0-SNAPSHOT/servlet/authentication/onetimetoken.html#page-title&quot;&gt;One-Time-Token Login&lt;/a&gt; with Spring Security, sending tokens to the user¡¯s email address (something they have), in addition to using Username/Password Login.&lt;/p&gt;
&lt;p&gt;This time, we¡¯ll create a custom &lt;code&gt;AuthorizationManager&lt;/code&gt; that looks at the current &lt;code&gt;Authentication&lt;/code&gt; programmatically.
For example, let¡¯s say that we want to require that the &lt;code&gt;admin&lt;/code&gt; user uses both factors; this may look something like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Component
class AdminMfaAuthorizationManager implements AuthorizationManager&amp;#x3C;Object&gt; {
    private final AuthorizationManager&amp;#x3C;Object&gt; mfa = AllAuthoritiesAuthorizationManager
            .hasAllAuthorities(FactorGrantedAuthority.OTT_AUTHORITY, FactorGrantedAuthority.PASSWORD_AUTHORITY);

    @Override
    public AuthorizationResult authorize(
        Supplier&amp;#x3C;? extends @Nullable Authentication&gt; authentication, Object context) {
        if (&quot;admin&quot;.equals(authentication.get().getName())) {
            return this.mfa.authorize(authentication, context);
        } else {
            return new AuthorizationDecision(true);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, we can now use Spring Security¡¯s default implementation of &lt;code&gt;DefaultAuthorizationManagerFactory&lt;/code&gt; and instruct it to append this authorization manager to all authorization rules:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Bean
AuthorizationManagerFactory&amp;#x3C;Object&gt; authorizationManagers(AdminMfaAuthorizationManager admins) {
    DefaultAuthorizationManagerFactory&amp;#x3C;Object&gt; defaults = new DefaultAuthorizationManagerFactory&amp;#x3C;&gt;();
    defaults.setAdditionalAuthorization(admins);
    return defaults;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, all web and method security rules will implicitly check this authorization manager as well.&lt;/p&gt;
&lt;h2 id=&quot;issuing-authorities-yourself&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#issuing-authorities-yourself&quot; aria-label=&quot;issuing authorities yourself permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Issuing Authorities Yourself&lt;/h2&gt;
&lt;p&gt;Your custom authentication mechanisms can seamlessly participate as well.
All that is needed is for your &lt;code&gt;AuthenticationProvider&lt;/code&gt; to issue a &lt;code&gt;FactorGrantedAuthority&lt;/code&gt; with a name that rules can use to identify it.&lt;/p&gt;
&lt;p&gt;Consider a biometric authentication provider like this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class MyBiometricAuthenticationProvider implements AuthenticationProvider {
    @Override
    public Authentication authenticate(Authentication authentication) {
        // ..,.
        UserDetails user = this.users.findUserByUsername(username);
        Collection&amp;#x3C;GrantedAuthority&gt; authorities = new HashSet&amp;#x3C;&gt;(user.getAuthorities());
        return new UsernamePasswordAuthenticationToken(username, null, authorities);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition to any user-level authorities you grant, you can also grant an infrastructural authority of your own:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;class MyBiometricAuthenticationProvider implements AuthenticationProvider {
    @Override
    public Authentication authenticate(Authentication authentication) {
        // ..,.
        UserDetails user = this.users.findUserByUsername(username);
        Collection&amp;#x3C;GrantedAuthority&gt; authorities = new HashSet&amp;#x3C;&gt;(user.getAuthorities());
        authorities.add(FactorGrantedAuthority.withFactor(&quot;THUMBPRINT&quot;).build());
        return new UsernamePasswordAuthenticationToken(username, null, authorities);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, you can add authorization rules of your own that require that the user provide a thumbprint to access a given resource.&lt;/p&gt;
&lt;h2 id=&quot;going-passwordless&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#going-passwordless&quot; aria-label=&quot;going passwordless permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Going Passwordless&lt;/h2&gt;
&lt;p&gt;MFA plays a large role in allowing applications to go passwordless.
You can, for example, now require a &lt;a href=&quot;https://docs.spring.io/spring-security/reference/7.0-SNAPSHOT/servlet/authentication/passkeys.html#page-title&quot;&gt;Passkey&lt;/a&gt; and a Biometric scan with a few simple configurations.&lt;/p&gt;
&lt;p&gt;Begin with adding the annotation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@EnableGlobalMultiFactorAuthentication(authorities = {
    FactorGrantedAuthority.WEBAUTHN_AUTHORITY,
    &quot;FACTOR_THUMBPRINT&quot;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[NOTE]
Notice that this example is using a custom authentication provider that verifies the user¡¯s biometric data.&lt;/p&gt;
&lt;p&gt;Then, add the authentication mechanisms:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Bean
Customizer&amp;#x3C;HttpSecurity&gt; webAuthn() {
    return (http) -&gt; http
        .webAuthn((webAuthn) -&gt; webAuthn
            .rpName(&quot;Spring Security Relying Party&quot;)
            .rpId(&quot;example.com&quot;)
            .allowedOrigins(&quot;https://example.com&quot;));
}

@Bean
Customizer&amp;#x3C;HttpSecurity&gt; biometrics() {
    return (http) -&gt; http.authenticationProvider(new MyBiometricsAuthenticationProvider());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that¡¯s it!&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#wrapping-up&quot; aria-label=&quot;wrapping up permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;Let¡¯s wrap up. Multi-Factor Authentication is a powerful new feature in Spring Security 7 that allows you to require more than one factor based on authorization rules that specify which factors they require. You can use &lt;code&gt;@EnableGlobalMultiFactorAuthentication&lt;/code&gt; to specify factor rules that apply globally or &lt;code&gt;AuthorizationManagerFactory&lt;/code&gt; for rules that apply, given some condition. And your custom authentication mechanisms can play along as well by adding a &lt;code&gt;FactorGrantedAuthority&lt;/code&gt; instance into their &lt;code&gt;Authentication&lt;/code&gt;¡¯s list of granted authorities.&lt;/p&gt;
&lt;p&gt;To learn more, check out the &lt;a href=&quot;https://github.com/spring-projects/spring-security-samples/tree/main/servlet/spring-boot/java/authentication/mfa&quot;&gt;sample code in &lt;code&gt;spring-security-samples&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;https://docs.spring.io/spring-security/reference/7.0-SNAPSHOT/servlet/authentication/mfa.html&quot;&gt;reference documentation&lt;/a&gt;.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring Authorization Server 1.5.3 and 1.4.6 available now]]></title><link>https://spring.io/blog/2025/10/21/spring-authorization-server-1-5-3-and-1-4-6-available-now</link><guid isPermaLink="true">https://spring.io/blog/2025/10/21/spring-authorization-server-1-5-3-and-1-4-6-available-now</guid><dc:creator><![CDATA[jgrandja]]></dc:creator><pubDate>Tue, 21 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;On behalf of the team and everyone who has contributed, it is my pleasure to announce the releases of Spring Authorization Server 1.5.3 and 1.4.6.&lt;/p&gt;
&lt;p&gt;See the &lt;a href=&quot;https://github.com/spring-projects/spring-authorization-server/releases/tag/1.5.3&quot;&gt;1.5.3&lt;/a&gt; and &lt;a href=&quot;https://github.com/spring-projects/spring-authorization-server/releases/tag/1.4.6&quot;&gt;1.4.6&lt;/a&gt; release notes for complete details.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spring.io/projects/spring-authorization-server&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-authorization-server/issues&quot;&gt;GitHub Issues&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Spring for GraphQL 1.4.3 released]]></title><link>https://spring.io/blog/2025/10/21/spring-for-graphql-1-4-3-released</link><guid isPermaLink="true">https://spring.io/blog/2025/10/21/spring-for-graphql-1-4-3-released</guid><dc:creator><![CDATA[bclozel]]></dc:creator><pubDate>Tue, 21 Oct 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;I am pleased to announce that Spring for GraphQL 1.4.3 is now available on Maven Central.
This release closes &lt;a href=&quot;https://github.com/spring-projects/spring-graphql/releases/tag/v1.4.3&quot;&gt;5 issues&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This version will ship with Spring Boot 3.5.7, &lt;a href=&quot;https://spring.io/projects#release-calendar&quot;&gt;to be released this week&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;how-can-you-help&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#how-can-you-help&quot; aria-label=&quot;how can you help permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;How can you help?&lt;/h3&gt;
&lt;p&gt;If you have general questions, please ask on &lt;a href=&quot;https://stackoverflow.com&quot;&gt;stackoverflow.com&lt;/a&gt; using the &lt;a href=&quot;https://stackoverflow.com/tags/spring-graphql&quot;&gt;&lt;code&gt;spring-graphql&lt;/code&gt; tag&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://spring.io/projects/spring-graphql/&quot;&gt;Project Page&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-graphql&quot;&gt;GitHub&lt;/a&gt; | &lt;a href=&quot;https://github.com/spring-projects/spring-graphql/issues&quot;&gt;Issues&lt;/a&gt; | &lt;a href=&quot;https://docs.spring.io/spring-graphql/reference&quot;&gt;Documentation&lt;/a&gt; | &lt;a href=&quot;https://stackoverflow.com/questions/tagged/spring-graphql&quot;&gt;Stack Overflow&lt;/a&gt;&lt;/p&gt;</content:encoded></item></channel></rss>